### 비효율적인 의존성 검색

NPM의 방식 ⇒ 익숙한 `node_modules` 폴더를 이용 ⇒ 이렇게 관리하면 의존성 검색은 비효율적으로 동작함

어떻게 비효율적으로?

- NPM은 패키지를 찾기 위해서 계속 상위 디렉토리의 node_modules 폴더를 탐색합니다. 따라서 패키지를 바로 찾지 못할수록 readdir, stat과 같은 느린 I/O 호출이 반복됩니다. 경우에 따라서는 I/O 호출이 중간에 실패하기도 합니다.

### 환경에 따라 달라지는 동작

NPM은 패키지를 찾지 못하면 상위 디렉토리의 `node_modules` 폴더를 계속해서 검색합니다. 이 때문에 어떤 의존성을 찾을 수 있는지는 해당 패키지의 상위 디렉토리에 따라서 달라집니다.

→ 이렇게 환경에 따라서 동작이 변하는 것은 😈

### 비효율적인 설치

`node_module` 디렉토리 구조는 매우 큰 공간을 차지합니다.

단점:

1. 용량 차지
2. 큰 디렉토리 구조를 만들기 위해서는 많은 I/O 작업이 필요함

`node_modules` 폴더는 복잡하기 때문에 설치가 유효한지 검증하기 어렵습니다.

-> 이렇게 깊은 트리 구조에서 의존성이 잘 설치되어 있는지 검증하려면 많은 수의 I/O 호출이 필요합니다. 일반적으로 디스크 I/O 호출은 메모리의 자료구조를 다루는 것보다 훨씬 느립니다. 이런 문제로 인해 Yarn v1이나 NPM은 기본적인 의존성 트리의 유효성까지만 검증하고, 각 패키지의 내용이 올바른지는 확인하지 않습니다.

### 유령 의존성

![스크린샷 2024-03-27 오전 9.37.06.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/51dd44a8-3352-4315-a59a-c74ab3755003/8e44f3d7-9598-4f56-bd82-13c74d798ae3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-03-27_%E1%84%8B%E1%85%A9%E1%84%8C%E1%85%A5%E1%86%AB_9.37.06.png)

예를 들어, 의존성 트리가 왼쪽의 모습이라고 한다면, A(1.0)과 B(1.0) 패키지는 두 번 설치 되므로 디스크 공간을 낭비합니다. 이를 막기 위해서 Yarn v1과 NPM에서는 오른쪽 트리처럼 바꿉니다.

→ 오른쪽 트리로 의존성 트리가 바뀌면서 package-1 에서는 원래 require() 할 수 없었던 **[B (1.0)]** 라이브러리를 불러올 수 있게 되었습니다.

→ 이렇게 끌어올리기에 따라서 직접 의존하지 않고 있는 라이브러리르 require할 수 있는 현상을 유령 의존성이라고 부릅니다.

→ 유령 의존성 현상이 발생할 때, package.json에 명시하지 않은 라이브러리를 조용히 사용할 수 있게 됩니다. 다른 의존성을 package.json 에서 제거했을 때 소리없이 같이 사라지기도 합니다. 이런 특성은 의존성 관리 시스템을 혼란스럽게 만듭니다.

---

### Plug’n’Play (PnP)

패키지 매니저들이 node_modules 디렉토리 구조를 만드는 것에 그치지 않고, 보다 근본적으로 안전하게 의존성을 관리하자!는 생각에서 출발하였다.

### **Plug'n'Play의** 동작 방법

yarn berry는 `node_modules`를 생성하지 않습니다. `.yarn/cache` 폴더에 의존성의 정보가 저장되고, `.pnp.cjs` 파일에 의존성을 찾을 수 있는 정보가 기록됩니다. `.pnp.cjs`를 이용하면 디스크 I/O 없이 어떤 패키지가 어떤 라이브러리에 의존하는지, 각 라이브러리는 어디에 위치하는지를 바로 알 수 있습니다.

[ `.pnp.cjs` 파일 내용 ⬇️ ]

```jsx
/* react 패키지 중에서 */
["react", [
  /* npm:17.0.1 버전은 */
  ["npm:17.0.1", {
    /* 이 위치에 있고 */
    "packageLocation": "./.yarn/cache/react-npm-17.0.1-98658812fc-a76d86ec97.zip/node_modules/react/",
    /* 이 의존성들을 참조한다. */
    "packageDependencies": [
      ["loose-envify", "npm:1.4.0"],
      ["object-assign", "npm:4.1.1"]
    ],
  }]
]],

```

Yarn은 Node.js가 제공하는 `require()` 문의 동작을 덮어씀으로써 효율적으로 패키지를 찾을 수 있도록 합니다. 이 때문에 PnP API를 이용하여 의존성 관리를 하고 있을 때에는 `node` 명령어 대신 `yarn node` 명령어를 사용해야 합니다.

실행할 때는 마찬가지로 `yarn dev` 사용

### ZipFS(Zip Filesystem)

zip으로 묶인 폴더를 `.yarn/chache`에서 관리함

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/51dd44a8-3352-4315-a59a-c74ab3755003/dcbfa450-a489-45da-b189-2553d876c53b/Untitled.png)

Yarn PnP 시스템에서 각 의존성은 Zip 아카이브로 관리됩니다. 예를 들어, Recoil 0.1.2 버전은 `recoil-npm-0.1.2-9a0edbd2b9-c69105dd7d.zip`과 같은 압축 파일로 관리됩니다.

이후 `.pnp.cjs` 파일이 지정하는 바에 따라 동적으로 Zip 아카이브의 내용이 참조됩니다.

의존성을 Zip 아카이브로 관리하면 생기는 장점:

1. 더 이상 `node_modules` 디렉토리 구조를 생성할 필요가 없기 때문에 설치가 신속하다.
2. 각 패키지는 버전마다 하나의 Zip 아카이브만을 가지기 때문에, 중복해서 설치되지 않는다.
    
    압축되어있어서 스토리지 용량을 아낄 수 있다.
    
    예시) 토스팀 NPM 사용시, 400MB ↔ Yarn PnP 사용시, 129MB
    
3. 의존성을 구성하는 파일의 수가 많지 않으므로, 변경 사항을 감지하거나 전체 의존성을 삭제하는 작업이 빠르다.
    
    → 없는 의존성이나 더 이상 필요 없는 의존성을 쉽게 찾기 가능
    
    → Zip 파일의 내용이 변경되엇을 때에는 체크섬과 비교해 쉽게 변경 여부를 감지할 수 있음
    

### Plug’n’Play 도입 결과

1. 의존성 검색 시,
    
    `node_modules` 폴더 순회할 필요 없음
    
    → `.pnp.cjs` 파일이 제공하는 자료구조를 이용하여 바로 의존성의 위치를 찾기 때문입니다. 이로써 `require()`에 걸리는 시간이 크게 단축
    
2. 재현 가능성
    
    `.pnp.cjs` 파일로 관리되기 때문에 외부 영향을 받지 않음
    
    이로써 다양한 기기 및 CI 환경에서 require() 또는 import 문의 동작이 동일할 것을 보장
    
3. 의존성 설치 시,
    
    `Zero-install`을 사용하면 대부분 라이브러리를 설치 없이 사용
    
4. 엄격한 의존성 관리
    
    Yarn PnP는 `node_modules`에서와 같이 의존성을 끌어올리지 않음
    
    → 패키지들은 자신이 package.json에 기술하는 의존성에만 접근할 수 있습니다. 
    
    기존에 환경에 따라 우연히 작동할 수 있었던 코드들이 보다 엄격히 관리됨 !
    
    → 이로써 예기치 못한 버그를 쉽게 일으키던 **유령 의존성 현상**을 근본적으로 막을 수 있음 !
    
5. 의존성 검증
    
    `node_modules`를 사용해서 관리 할 때, 의존성이 올바르지 못하게 설치 되어서 다 지우고 다시 설치해야하는 경우들 때문에시간이 낭비됨
    
    → BUT Yarn PnP에서는 Zip 파일을 이용하여 패키지를 관리하기 때문에 빠진 의존성을 찾거나 의존성 파일이 변경되었음을 찾기 쉬움
    
    → 이로써 의존성이 잘못되었을 때 쉽게 바로잡을 수 있다! 이로써 올바르게 의존성이 설치되는 것을 100%에 가깝게 보장할 수 있다!
