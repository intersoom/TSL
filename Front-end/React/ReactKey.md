### key 값이 필요한 이유

리액트에서 map을 활용해서 이터러블 객체를 생성할 때는 key값을 입력하라고 경고를 띄운다

왜 그럴까?

**컴포넌트의 고유성**

리액트에서는 컴포넌트마다 고유의 값을 가진다 

→ `useState`, `useRef`를 사용해서 컴포넌트가 리렌더링 되더라도 이전의 상태나 값을 기억할 수 있음

근데 이때, 컴포넌트 내부에 메모리를 가지고 있다면, key 값은 필요 없을 것이다

하지만 리액트의 메모리는 리액트의 내부 인스턴스와 상태 저장 매커니즘에 저장된다

그 후 렌더링 과정으로 생성된 UI 트리에 따라 컴포넌트에 순차적으로 연결됨 (실은 조금 더 복잡한 과정)

문제는 key 값이 없으면, 리렌더링 될 때 그 순서가 바뀔 수 있다는 것

1. **만약 key 값을 넣어주지 않으면**
    
    메모리 - UI 트리가 각각 연결되는데,
    
    `A - B - C` 순서로 있던 UI 트리가 `A - C - B` 순서로 바뀌면, 메모리가 원하는 UI 트리에 할당되지 않는다
    
    UI는 `A - C - B` 순인데, 메모리는 `A - B - C`로 할당되는 문제가 발생한다!
    
    (유저가 따로 key 값을 넣어주지 않으면, index를 key 값으로 할당함)
    
    ⇒ **이처럼 각 컴포넌트 메모리는 `어떤 컴포넌트`에 연결되는 것이 아닌 `어디에 있는 컴포넌트`에 연결되고 이는 기대와 다른 결과를 가져올 수 있다**
    
2. **만약 key 값을 넣어주면**
    
    UI 트리의 위치를 기준으로 메모리를 할당하는 것이 나리 key 값을 기준으로 할당해줌
    
    따라서 기대하던 대로 컴포넌트가 작동함!
    

> `key` 값은 고유해야하며, 이는 형제 요소 사이에서만 고유하면 된다
> 

### key 값에 index를 사용하면 안되는 이유

리액트에서 key 값으로 기본적으로 index를 사용하는데, 이를 사용하면 안되는 이유에 대해서 알아보자

**리액트의 가상 DOM**

리액트는 렌더링 시에 가상 DOM을 생성하고 재조정 과정에서 이전 렌더와 새로운 렌더를 비교하여 차이가 나는 부분만 DOM에 적용함

→ **리액트의 성능 최적화**

만약에 이렇게 되어있던 코드가

```tsx
export const App = () => {
  const [arr, setArr] = useState(['A', 'B', 'C']);

  return (
    <ul>
      {arr.map((alphabet, index) => (
        <li key={index}>{alphabet}</li>
      ))}
    </ul>
  );
};
```

이렇게 D가 추가된다면,

```tsx
export const App = () => {
  const [arr, setArr] = useState(['A', 'D', 'B', 'C']);

  return (
    <ul>
      {arr.map((alphabet, index) => (
        <li key={index}>{alphabet}</li>
      ))}
    </ul>
  );
};
```

B와 C의 key 값이 `1 → 2`, `2 → 3`으로 변경된다

**key 값이 변경되면 발생하는 문제점**

key 값이 변경되면 리액트는 해당 컴포넌트를 아예 새로운 컴포넌트로 간주하고 이전 인스턴스를 파괴했다가 새로운 인스턴스를 생성한다

(해당 특징을 이용한다면, `key`가 필요하지 않은 `단일 요소`에 의도적으로 `key`를 할당하거나 변경하는 것으로 해당 컴포넌트의 `상태를 초기화`할 수 있다)

이때, 발생하는 문제점은 위에서 언급한대로 B와 C의 key 값이 변함으로써 내부가 전혀 변하지 않았음에도 불구하고 인스턴스가 재생성된다는 것이다

→ 이는 리액트의 성능 최적화 측면에서 안 좋다!
