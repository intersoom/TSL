## 백트래킹
### 백트래킹이란?
- 현재 상태에서 가능한 모든 경로를 따라 들어가 탐색하다, 원하는 값과 불일치하는 부분이 발생하면 더 이상 탐색을 진행하지 않고 전 단계로 돌아가는, 즉 이름 그대로 방금 왔던 길을 되짚어가는, backtrack하는 알고리즘
### 백트래킹 사용하는 경우
    - 모든 경우의 수를 확인해야할 때 (예: 순열)
    - for로는 확인이 불가능할 때 (깊이가 달라질 때)
        - m,n 값이 다른 경우
    
    ```jsx
    def recur(num): // num은 깊이를 확인하는 매개변수!
    	if num == m: // 깊이 충족되면 return (확인 완료됨)
    		return
    	else:
    		for 1 ~ N // 다음 깊이로 가는 과정
    			값 추가
    		recur(num)
    ```
    
### 백트래킹이랑 DFS
    - 모두 탐색하는 알고리즘이라는 점에서 유사하지만
    - 백트래킹은 불필요한 탐색을 하지 않음
        - **백트래킹**
            
            **`a = 132, 234, 123`** 총 3개의 요소를 가지고 있는데, 123이라는 값을 찾고 있다고 하자. 순서대로 132라는 값에 접근했을 때, 백의 자리 수가 동일하나, 십의 자리 수가 다르기 때문에 더 이상 탐색을 진행하지 않고 다음 수로 넘어간다.
            
            단계별로 탐색해서 특정 단계에서 조건 충족하지 않으면, 다음 단계로 진출되지 않음!
            
        - **DFS**
            
            32이라는 수를 탐색할 때, 십의 자리 수에 접근했을 때 원하는 수가 아님에도 불구하고 일의 자리 수까지, 즉 트리의 바닥에 도달할 때까지 탐색을 계속한다.
            
### 백트래킹 구현
    - **Promising** : 트리 구조를 기반으로 DFS로 깊이 탐색을 진행하면서 각 루트에 대해 조건에 부합하는지 체크한다.
    - **Pruning** : 해당 트리에서 조건에 맞지않는 노드는 더 이상 DFS로 깊이 탐색을 진행하지 않고 가지치기를 한다.
    
    ```jsx
    def 백트래킹(n):
    	if 정답이면 :
    		출력 or 저장
    	else :
    		for 모든 자식 노드에 대해 :
    			if 유망한지확인(m) :
    				자식노드로 이동
    				백트래킹(n+1)
    				부모노드로 이동
    
    def 유망한지확인(m):
    	if 조건에 안맞으면 :
    		return False
    	return True
    ```
    
### 시간 복잡도
    - 중복 가능: N^N, N = 8까지 가능
    - 중복 불가능: N!, N = 10까지 가능
